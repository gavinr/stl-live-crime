import{gf as e,e_ as t,gg as n,gh as i,gi as r,b9 as s}from"./vendor.0f6f771b.js";class o{constructor(){this.code=null,this.description=null}}class l{constructor(e){this.error=new o,this.globalId=null,this.objectId=null,this.success=!1,this.uniqueId=null,this.error.description=e}}function a(e){return new l(e)}class u{constructor(e){this.globalId=null,this.success=!0,this.objectId=this.uniqueId=e}}function c(e){return new u(e)}const f=new Set;function d(e,t,n,s,o=!1,l){f.clear();for(const u in n){const s=e.get(u);if(!s)continue;const c=n[u],d=g(s,c);if(d!==c&&l&&l.push({name:"invalid-value-type",message:"attribute value was converted to match the field type",details:{field:s,originalValue:c,sanitizedValue:d}}),f.add(s.name),s&&(o||s.editable)){const e=i(s,d);if(e)return a(r(e,s,d));t[s.name]=d}}if(s)for(const i of s)if(!f.has(i.name))return a(`missing required field "${i.name}"`);return null}function g(i,r){let s=r;return"string"==typeof r&&e(i)?s=parseFloat(r):null!=r&&t(i)&&"string"!=typeof r&&(s=String(r)),n(s)}let h;function m(e,t){if(!e||!s(t))return e;if("rings"in e||"paths"in e){if(!h)throw new TypeError("geometry engine not loaded");return h.simplify(t,e)}return e}async function p(e,t){!s(e)||"esriGeometryPolygon"!==t&&"esriGeometryPolyline"!==t||await async function(){return h||(h=await import("./geometryEngineJSON.2d3f87ef.js"),h)}()}export{c,d,m as h,a as u,p as y};
