var e=Object.defineProperty,t=Object.defineProperties,i=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,a=(t,i,s)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s,o=(e,t)=>{for(var i in t||(t={}))n.call(t,i)&&a(e,i,t[i]);if(s)for(var i of s(t))r.call(t,i)&&a(e,i,t[i]);return e},l=(e,s)=>t(e,i(s));import{Q as d,eM as u,J as p,g1 as y,g2 as c,cm as f,bE as m,bS as g,cg as h,a$ as b,cd as j,cf as I,g3 as F}from"./vendor.6e209a4d.js";import{u as _}from"./FeatureStore.5f6e7a90.js";import{y as E,p as T}from"./quantizationUtils.9cb72431.js";import{H as q}from"./QueryEngine.a48effac.js";import{I as x,T as w,k as O}from"./geojson.6fe2db6a.js";import{u as D,i as R,n as S}from"./clientSideDefaults.d83baf45.js";import{y as Q,d as v,c as k,u as P,h as C}from"./sourceUtils.ce601d04.js";import"./aaBoundingBox.45e1d856.js";import"./PooledRBush.7888d603.js";import"./quickselect.c0fda8e0.js";import"./centroid.f7592ee4.js";import"./json.df9e51f4.js";import"./WhereClause.7d3ac4db.js";import"./QueryEngineCapabilities.54eb86f4.js";import"./utils.3ea7c765.js";import"./spatialQuerySupport.96e2380d.js";const Z={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};class A{constructor(){this._queryEngine=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._requiredFields=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const t=[];await this._checkProjection(e.spatialReference);let i=null;e.url&&(i=(await d(e.url,{responseType:"json"})).data,await x(i));const s=w(i,{geometryType:e.geometryType}),n=e.fields||s.fields||[],r=null!=e.hasZ?e.hasZ:s.hasZ,a=s.geometryType,b=e.objectIdField||("number"===s.objectIdFieldType?s.objectIdFieldName:"OBJECTID")||"OBJECTID",j=e.spatialReference||u;let I=e.timeInfo;if(!a)throw new p("geojson-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if("string"===s.objectIdFieldType&&t.push({name:"geojson-layer:unsupported-id-type",message:"Feature ids are of type string and can't be honored."}),n===s.fields&&s.unknownFields.length>0&&t.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:s.unknownFields}}),b){let e=null;n.some((t=>t.name===b&&(e=t,!0)))?(e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):n.unshift({alias:b,name:b,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const o of n){if(null==o.name&&(o.name=o.alias),null==o.alias&&(o.alias=o.name),!o.name)throw new p("geojson-layer:invalid-field-name","field name is missing",{field:o});if(o.name===b&&(o.type="esriFieldTypeOID"),-1===y.jsonValues.indexOf(o.type))throw new p("geojson-layer:invalid-field-type",`invalid type for field "${o.name}"`,{field:o})}const F={};this._requiredFields=[];for(const o of n)if("esriFieldTypeOID"!==o.type&&"esriFieldTypeGlobalID"!==o.type){o.editable=null==o.editable||!!o.editable,o.nullable=null==o.nullable||!!o.nullable;const e=c(o);o.nullable||void 0!==e?F[o.name]=e:this._requiredFields.push(o)}if(this._fieldsIndex=new f(n),I){if(I.startTimeField){const e=this._fieldsIndex.get(I.startTimeField);e?(I.startTimeField=e.name,e.type="esriFieldTypeDate"):I.startTimeField=null}if(I.endTimeField){const e=this._fieldsIndex.get(I.endTimeField);e?(I.endTimeField=e.name,e.type="esriFieldTypeDate"):I.endTimeField=null}if(I.trackIdField){const e=this._fieldsIndex.get(I.trackIdField);e?I.trackIdField=e.name:(I.trackIdField=null,t.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:I}}))}I.startTimeField||I.endTimeField||(t.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:I}}),I=null)}const T={warnings:t,featureErrors:[],layerDefinition:l(o({},Z),{drawingInfo:D(a),templates:R(F),extent:null,geometryType:a,objectIdField:b,fields:n,hasZ:!!r,timeInfo:I})};this._queryEngine=new q({fields:n,geometryType:a,hasM:!1,hasZ:r,objectIdField:b,spatialReference:j,timeInfo:I,featureStore:new _({geometryType:a,hasM:!1,hasZ:r}),cacheSpatialQueries:!0}),this._createDefaultAttributes=S(F,b),this._nextObjectId=s.maxObjectId+1;const Q=O(i,{geometryType:a,hasZ:r,objectIdField:"number"===s.objectIdFieldType?b:null});if(!m(j,u))for(const o of Q)o.geometry&&(o.geometry=g(E(h(o.geometry,a,r,!1),u,j)));return this._loadInitialFeatures(T,Q),T}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await Promise.all([Q(t,i),T(e.adds,t),T(e.updates,t)]),this._applyEdits(e)}queryFeatures(e={},t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e={},t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e={},t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e={},t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_loadInitialFeatures(e,t){const{featureStore:i,objectIdField:s}=this._queryEngine,n=[];for(const r of t){const t=this._createDefaultAttributes(),i=v(this._fieldsIndex,t,r.attributes,this._requiredFields,!0,e.warnings);i?e.featureErrors.push(i):(this._assignObjectId(t,r.attributes,!0),r.attributes=t,r.objectId=t[s],n.push(r))}if(i.addMany(n),e.layerDefinition.extent=this._queryEngine.fullExtent,e.layerDefinition.timeInfo){const{start:t,end:i}=this._queryEngine.timeExtent;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}_applyEdits(e){const{adds:t,updates:i,deletes:s}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(n,t),i&&i.length&&this._applyUpdateEdits(n,i),s&&s.length){for(const e of s)n.deleteResults.push(k(e));this._queryEngine.featureStore.removeManyById(s)}return{fullExtent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:i}=e,{geometryType:s,hasM:n,hasZ:r,objectIdField:a,spatialReference:o,featureStore:l}=this._queryEngine,d=[];for(const u of t){if(u.geometry&&s!==b(u.geometry)){i.push(P("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),n=v(this._fieldsIndex,t,u.attributes,this._requiredFields);if(n)i.push(n);else{if(this._assignObjectId(t,u.attributes),u.attributes=t,null!=u.uid){const t=u.attributes[a];e.uidToObjectId[u.uid]=t}u.geometry&&(u.geometry=E(C(u.geometry,o),u.geometry.spatialReference,o)),d.push(u),i.push(k(u.attributes[a]))}}l.addMany(j([],d,s,r,n,a))}_applyUpdateEdits({updateResults:e},t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:r,spatialReference:a,featureStore:o}=this._queryEngine;for(const l of t){const{attributes:t,geometry:d}=l,u=t&&t[r];if(null==u){e.push(P(`Identifier field ${r} missing`));continue}if(!o.has(u)){e.push(P(`Feature with object id ${u} missing`));continue}const p=I(o.getFeature(u),i,n,s);if(d){if(i!==b(d)){e.push(P("Incorrect geometry type."));continue}p.geometry=E(C(d,a),d.spatialReference,a)}if(t){const i=v(this._fieldsIndex,p.attributes,t,this._requiredFields);if(i){e.push(i);continue}}o.add(F(p,i,n,s,r)),e.push(k(u))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}async _checkProjection(e){try{await T(u,e)}catch{throw new p("geojson-layer","Projection not supported")}}}export{A as default};
